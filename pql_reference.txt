================================================================================
PREDICTIVE QUERY LANGUAGE (PQL) — REFERENCE FOR QUERY GENERATION
================================================================================

PQL is a declarative syntax for defining ML prediction tasks. It defines
WHAT to predict and WHO to predict for. The model infers the task type
automatically from the query structure.

================================================================================
SECTION 1: CORE SYNTAX
================================================================================

Structure:
  PREDICT <target>
  FOR <entity_table>.<entity_id_column> = <value>
  [WHERE <filter>]

Or with multiple entities:
  PREDICT <target>
  FOR <entity_table>.<entity_id_column> IN (<val1>, <val2>, ...)
  [WHERE <filter>]

Components:
- PREDICT: The value/outcome to predict
- FOR:     The entity to predict for, with explicit IDs
- WHERE:   (Optional) Filters historical context data for features
           Does NOT limit which entities are predicted for

IMPORTANT: Always use FOR entity.id = value or FOR entity.id IN (list).
Do NOT use FOR EACH (unsupported). Do NOT use EVALUATE PREDICT (unsupported).

================================================================================
SECTION 2: TARGET TYPES
================================================================================

A) STATIC FIELD (Missing Value Imputation)
   Pattern:  PREDICT <table>.<column>
   Example:  PREDICT users.age FOR users.user_id=8
   Use when: Predicting a missing attribute of an entity
   Note:     No aggregation, no time window

B) TIME-BASED AGGREGATION (Temporal Prediction)
   Pattern:  PREDICT AGG(<table>.<column>, <start>, <end>[, <unit>])
   Example:  PREDICT SUM(orders.price, 0, 30, days) FOR users.user_id=123
   Use when: Predicting future behavior over a time window

================================================================================
SECTION 3: AGGREGATION FUNCTIONS & COLUMN TYPE COMPATIBILITY
================================================================================

Function         | Valid Column Types        | Example
-----------------+--------------------------+------------------------------------------
SUM              | numeric ONLY             | SUM(orders.price, 0, 30)
AVG              | numeric ONLY             | AVG(reviews.rating, 0, 12, months)
MAX              | numeric ONLY             | MAX(orders.price, 0, 30, days)
MIN              | numeric ONLY             | MIN(orders.price, 0, 7)
COUNT            | * wildcard (counts rows)  | COUNT(orders.*, 0, 90, days)
COUNT_DISTINCT   | categorical/text ONLY    | COUNT_DISTINCT(purchases.category, 0, 90)
                 | NEVER on ID/PK/FK columns |
LIST_DISTINCT    | FK or categorical ONLY   | LIST_DISTINCT(orders.item_id, 0, 30, days)
                 | MUST include RANK TOP k   |

API REJECTS these combinations:
- SUM/AVG/MAX/MIN on ID, categorical, text, or time columns
- COUNT_DISTINCT on PK or FK columns (use COUNT with * instead)
- LIST_DISTINCT on numeric columns
- LIST_DISTINCT without RANK TOP k

Aggregation arguments: AGG(<table>.<column>, <start>, <end>[, <unit>])
- <start>: Start of time window (relative to prediction time)
- <end>:   End of time window
- <unit>:  One of: days (default), hours, months
- For PREDICT targets: start and end must be >= 0 (future only)
- For WHERE filters: start can be negative (past), end is typically 0
- end must be > start

Time window examples:
- (0, 30, days):   Next 30 days
- (0, 12, months): Next 12 months
- (-90, 0, days):  Past 90 days (ONLY in WHERE, not PREDICT)

================================================================================
SECTION 4: TASK TYPE DETECTION
================================================================================

KumoRFM infers the ML task from the PREDICT clause:

Pattern                                  | Task Type
-----------------------------------------+-------------------------
Raw numeric column (e.g. users.age)      | Regression
Numeric aggregation (SUM, AVG, MAX, MIN) | Regression
AGG(...) = 0  or  AGG(...) > 0           | Binary Classification
Categorical column                       | Multiclass Classification
Boolean expression (col = value)         | Binary Classification
LIST_DISTINCT(...) RANK TOP k            | Link Prediction/Ranking

Key: Adding "= 0", "> 0", "= 1" to an aggregation CHANGES it from
regression to binary classification.

================================================================================
SECTION 5: OPERATORS
================================================================================

Comparison:  =   !=   <   <=   >   >=
Logical:     AND   OR   NOT

In PREDICT targets:
- COUNT(orders.*, 0, 30) = 0    → churn (binary classification)
- COUNT(orders.*, 0, 7) > 0     → activity prediction (binary)
- table.column = 1              → like probability (binary)

In WHERE clauses:
- WHERE COUNT(events.*, -60, 0, days) > 0   → only active entities
- WHERE table.column = "value"               → static column filter

================================================================================
SECTION 6: LINK PREDICTION (Recommendations)
================================================================================

Pattern:
  PREDICT LIST_DISTINCT(<event_table>.<target_column>, <start>, <end>[, <unit>]) RANK TOP <k>
  FOR <entity_table>.<entity_id> = <value>

Predicts the top-k distinct values the entity will interact with.
The target_column must be an FK or categorical column.
Time window is required (static link prediction is not supported).

================================================================================
SECTION 7: INTENT-TO-PQL MAPPING
================================================================================

Business Intent         | PQL Pattern
------------------------+----------------------------------------------------------
Customer churn          | PREDICT COUNT(events.*, 0, N, days) = 0 FOR entity
Will-they-buy/engage    | PREDICT COUNT(events.*, 0, N, days) > 0 FOR entity
Revenue/LTV forecast    | PREDICT SUM(events.amount, 0, N, days) FOR entity
Average metric forecast | PREDICT AVG(events.metric, 0, N, unit) FOR entity
Max value forecast      | PREDICT MAX(events.value, 0, N, days) FOR entity
Product recommendation  | PREDICT LIST_DISTINCT(events.item, 0, N) RANK TOP k FOR entity
Missing attribute       | PREDICT entity.column FOR entity.id=val
Fraud/anomaly detection | PREDICT labels.is_fraud FOR entity.id=val
Engagement rate         | PREDICT AVG(events.is_positive, 0, N, months) FOR entity

================================================================================
SECTION 8: CONSTRUCTION RULES
================================================================================

1. ONLY reference tables and columns that exist in the provided schema
2. Use EXACT table and column names (case-sensitive)
3. Entity IDs in FOR clause must be actual IDs from the data
4. FOR clause must use the primary key column of the entity table
5. Target table must be reachable from entity table via FK links
6. Do NOT use time windows with imputation queries
7. Do NOT use negative start values in PREDICT targets (only in WHERE)
8. COUNT uses * wildcard only (counts rows)
9. WHERE filters context data, NOT the entity list

================================================================================
END OF REFERENCE
================================================================================